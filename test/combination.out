@main
	op: call 		dest: final		type: int		args: ["n", "k"]		funcs: ["combo"]
	op: print		args: ["final"]	
@combo
	op: const		dest: zero		type: int		value: 0	
	op: const		dest: one		type: int		value: 1	
	op: lt   		dest: nneg		type: bool		args: ["n", "zero"]	
	op: lt   		dest: kneg		type: bool		args: ["k", "zero"]	
	op: or   		dest: eitherneg		type: bool		args: ["nneg", "kneg"]	
	op: br   		args: ["eitherneg"]		labels: ["negatives", "natural"]
.negatives
	op: ret  		args: ["zero"]	
.natural
	op: eq   		dest: kzero		type: bool		args: ["k", "zero"]	
	op: br   		args: ["kzero"]		labels: ["zeroes", "positive"]
.zeroes
	op: ret  		args: ["one"]	
.positive
	op: lt   		dest: nltk		type: bool		args: ["n", "k"]	
	op: br   		args: ["nltk"]		labels: ["negatives", "valid"]
.valid
	op: call 		dest: nfac		type: int		args: ["n"]		funcs: ["factorial"]
	op: call 		dest: kfac		type: int		args: ["k"]		funcs: ["factorial"]
	op: sub  		dest: nmink		type: int		args: ["n", "k"]	
	op: call 		dest: nkfac		type: int		args: ["nmink"]		funcs: ["factorial"]
	op: mul  		dest: comboden		type: int		args: ["kfac", "nkfac"]	
	op: div  		dest: combo		type: int		args: ["nfac", "comboden"]	
	op: ret  		args: ["combo"]	
@factorial
	op: const		dest: one		type: int		value: 1	
	op: eq   		dest: basee		type: bool		args: ["x", "one"]	
	op: br   		args: ["basee"]		labels: ["base", "recurs"]
.base
	op: ret  		args: ["one"]	
.recurs
	op: sub  		dest: oneless		type: int		args: ["x", "one"]	
	op: call 		dest: stepback		type: int		args: ["oneless"]		funcs: ["factorial"]
	op: mul  		dest: fact		type: int		args: ["x", "stepback"]	
	op: ret  		args: ["fact"]	
